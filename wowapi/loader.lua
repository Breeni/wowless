local data = require('wowapi.data')
local yamlnull = require('lyaml').null

local function mixin(b, t)
  b = b or {}
  for k, v in pairs(t) do
    b[k] = v
  end
  return b
end

local loadApis = (function()
  local env = {
    require = require,
  }
  return function(version)
    local apis = {}
    for fn, yaml in pairs(data.yamls) do
      local match = not yaml.versions
      if yaml.versions then
        for _, v in ipairs(yaml.versions) do
          if version == v then
            match = true
          end
        end
      end
      if match then
        apis[fn] = yaml
      end
    end
    for fn, lua in pairs(data.luas) do
      if apis[fn] then
        mixin(apis[fn], setfenv(lua, env)())
      end
    end
    return apis
  end
end)()

local getStub = (function()
  local defaultOutputs = {
    bool = 'false',
    ['nil'] = 'nil',
    number = '1',
    oneornil = 'nil',
    string = '\'\'',
    table = '{}',
    unknown = 'nil',
  }
  local structureDefaults = (function()
    -- TODO generalize this
    return {
      Color = '{ r = 1, g = 1, b = 1 }',
      Vector2D = '{ x = 1, y = 1 }',
    }
  end)()
  return function(sig)
    local rets = {}
    for _, out in ipairs(sig) do
      local v = defaultOutputs[out.type] or structureDefaults[out.type]
      assert(v, ('invalid output type %q'):format(out.type))
      table.insert(rets, v)
    end
    return loadstring('return ' .. table.concat(rets, ', '))
  end
end)()

local argSig = (function()
  local typeSigs = {
    boolean = 'b',
    ['function'] = 'f',
    ['nil'] = 'x',
    number = 'n',
    string = 's',
    table = 't',
    userdata = 'u',
  }
  return function(fn, ...)
    -- Ignore trailing nils for our purposes.
    local last = select('#', ...)
    while last > 0 and (select(last, ...)) == nil do
      last = last - 1
    end
    local sig = ''
    for i = 1, last do
      local ty = type((select(i, ...)))
      local c = typeSigs[ty]
      if not c then
        error(('invalid argument %d of type %q to %q'):format(i, ty, fn))
      end
      sig = sig .. c
    end
    return sig
  end
end)()

local function unpackReturns(r)
  local ret = {}
  for i, v in ipairs(r) do
    ret[i] = v ~= yamlnull and v or nil
  end
  return unpack(ret, 1, #r)
end

local function doGetFn(api, modules)
  if api.status == 'autogenerated' or api.status == 'unimplemented' then
    assert(api.impl == nil, ('%q should not have an explicit implementation'):format(api.name))
    return getStub(api.outputs or {})
  elseif api.status == 'stub' then
    return assert(api.impl or api.returns and function() return unpackReturns(api.returns) end)
  elseif api.status == 'implemented' then
    return assert(modules[api.module].api[api.api])
  else
    error(('invalid status %q on %q'):format(api.status, api.name))
  end
end

local function getFn(api, modules, env)
  local stub = doGetFn(api, modules)
  return api.outputs == nil and stub or function(...)
    return (function(...)
      for idx, out in ipairs(api.outputs) do
        if out.mixin then
          local t = select(idx, ...)
          if t then
            env.Mixin(t, env[out.mixin])
          end
        end
      end
      return ...
    end)(stub(...))
  end
end

local function loadFunctions(version, env)
  local mods = {}
  for k, v in pairs(data.modules) do
    mods[k] = v(env)
  end
  local fns = {}
  for fn, api in pairs(loadApis(version)) do
    local bfn = getFn(api, mods, env)
    local impl = (function()
      if api.inputs == nil then
        return bfn
      end
      local apisigs = api.inputs
      if type(apisigs) == 'string' then
        apisigs = {apisigs}
      end
      if type(apisigs) ~= 'table' then
        error(('invalid inputs type on %q'):format(fn))
      end
      return function(...)
        local fsig = argSig(fn, ...)
        for _, x in ipairs(apisigs) do
          if fsig == x then
            return bfn(...)
          end
        end
        error(('invalid arguments to %q, expected one of {%s}, got %q'):format(fn, table.concat(apisigs, ', '), fsig))
      end
    end)()
    local dot = fn:find('%.')
    if dot then
      local p = fn:sub(1, dot-1)
      fns[p] = fns[p] or {}
      fns[p][fn:sub(dot+1)] = impl
    else
      fns[fn] = impl
    end
  end
  return fns
end

return {
  argSig = argSig,
  getFn = getFn,
  loadApis = loadApis,
  loadFunctions = loadFunctions,
}
